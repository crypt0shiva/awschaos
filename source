local Players = game:GetService("Players")
local pettoslime = "InfernoLeviathanSerpent"

-- Create a ScreenGui to hold the menu
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "MenuGui"
screenGui.Parent = Players.LocalPlayer.PlayerGui

-- Create a frame for the menu
local menuFrame = Instance.new("Frame")
menuFrame.Name = "MenuFrame"
menuFrame.Size = UDim2.new(0, 400, 1, 0)
menuFrame.Position = UDim2.new(0, -400, 0, 0)
menuFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
menuFrame.Parent = screenGui

-- Create a button to toggle the menu
local toggleButton = Instance.new("TextButton")
toggleButton.Name = "ToggleButton"
toggleButton.Size = UDim2.new(0, 80, 0, 30)
toggleButton.Position = UDim2.new(0, 10, 0, 10)
toggleButton.Text = "Toggle Menu"
toggleButton.Parent = screenGui

-- Create a toggle button for starting and stopping the farming script
local autoFarmingButton = Instance.new("TextButton")
autoFarmingButton.Name = "FarmingButton"
autoFarmingButton.Size = UDim2.new(0, 150, 0, 30)
autoFarmingButton.Position = UDim2.new(0, 10, 0, 50)
autoFarmingButton.Text = "Auto Farm: Off"
autoFarmingButton.Parent = menuFrame

-- Create a button to start/stop auto snack crafting
local autoSnackButton = Instance.new("TextButton")
autoSnackButton.Name = "AutoSnackButton"
autoSnackButton.Size = UDim2.new(0, 150, 0, 30)
autoSnackButton.Position = UDim2.new(0, 10, 0, 90)
autoSnackButton.Text = "Auto Snack Crafting: Off"
autoSnackButton.Parent = menuFrame

-- Create a button to start/stop auto merchant
local autoMerchantButton = Instance.new("TextButton")
autoMerchantButton.Name = "AutoMerchantButton"
autoMerchantButton.Size = UDim2.new(0, 150, 0, 30)
autoMerchantButton.Position = UDim2.new(0, 10, 0, 130)
autoMerchantButton.Text = "Auto Merchant: Off"
autoMerchantButton.Parent = menuFrame

-- Create a button to start/stop auto fight
local autoFightButton = Instance.new("TextButton")
autoFightButton.Name = "AutoFightButton"
autoFightButton.Size = UDim2.new(0, 150, 0, 30)
autoFightButton.Position = UDim2.new(0, 10, 0,170)
autoFightButton.Text = "Auto Fight: Off"
autoFightButton.Parent = menuFrame

-- Create a button to start/stop auto mutate
local autoMutateButton = Instance.new("TextButton")
autoMutateButton.Name = "AutoMutateButton"
autoMutateButton.Size = UDim2.new(0, 150, 0, 30)
autoMutateButton.Position = UDim2.new(0, 10, 0,210)
autoMutateButton.Text = "Auto Mutate: Off"
autoMutateButton.Parent = menuFrame

-- Create a button to start/stop auto slime
local autoSlimeButton = Instance.new("TextButton")
autoSlimeButton.Name = "AutoSlimeButton"
autoSlimeButton.Size = UDim2.new(0, 150, 0, 30)
autoSlimeButton.Position = UDim2.new(0, 10, 0,250)
autoSlimeButton.Text = "Auto Slime: Off"
autoSlimeButton.Parent = menuFrame

-- Create a button to remove the menu
local consoleButton = Instance.new("TextButton")
consoleButton.Name = "ConsoleButton"
consoleButton.Size = UDim2.new(0, 150, 0, 30)
consoleButton.Position = UDim2.new(0, 10, 0, 1100)
consoleButton.Text = "Console"
consoleButton.Parent = menuFrame



-- Create a button to remove the menu
local removeButton = Instance.new("TextButton")
removeButton.Name = "RemoveButton"
removeButton.Size = UDim2.new(0, 150, 0, 30)
removeButton.Position = UDim2.new(0, 10, 0, 950)
removeButton.Text = "Remove Menu"
removeButton.Parent = menuFrame



-- Create a button to start/stop auto hatch
local AutoMythLegendHatchButton = Instance.new("TextButton")
AutoMythLegendHatchButton.Name = "AutoMythLegendHatchButton"
AutoMythLegendHatchButton.Size = UDim2.new(0, 150, 0, 30)
AutoMythLegendHatchButton.Position = UDim2.new(0, 10, 0, 330)
AutoMythLegendHatchButton.Text = "Auto Hatch: Off"
AutoMythLegendHatchButton.Parent = menuFrame



local autoHatchPremiumButton = Instance.new("TextButton")
autoHatchPremiumButton.Name = "autoHatchPremiumButton"
autoHatchPremiumButton.Size = UDim2.new(0, 150, 0, 30)
autoHatchPremiumButton.Position = UDim2.new(0, 10, 0, 370)
autoHatchPremiumButton.Text = "Auto HatchPrem: Off"
autoHatchPremiumButton.Parent = menuFrame

-- Function to toggle the menu visibility
local function ToggleMenuVisibility()
    local targetPosition = menuFrame.Position.X.Offset == 0 and -400 or 0
    menuFrame:TweenPosition(UDim2.new(0, targetPosition, 0, 0), "Out", "Quad", 0.3, true)
end

-- Function to get the location table based on the location name
local function getLocationTable(locationName)
    
    if locationName == "school" then
        return {
            [1] = workspace:WaitForChild("Zones"):WaitForChild("1"):WaitForChild("Interactables"):WaitForChild("Teleports"):WaitForChild("Locations"):WaitForChild("BackToSchool")
        }
    elseif locationName == "garden" then
        return {
            [1] = workspace:WaitForChild("Zones"):WaitForChild("Garden"):WaitForChild("Interactables"):WaitForChild("Teleports"):WaitForChild("Locations"):WaitForChild("BackToSchool")
        }
    elseif locationName == "space" then
        return {
            [1] = workspace:WaitForChild("Zones"):WaitForChild("2"):WaitForChild("Interactables"):WaitForChild("Teleports"):WaitForChild("Locations"):WaitForChild("FuturisticBack")
        }
    elseif locationName == "beach" then
        return {
            [1] = workspace:WaitForChild("Zones"):WaitForChild("3"):WaitForChild("Interactables"):WaitForChild("Teleports"):WaitForChild("Locations"):WaitForChild("Beach")
        }
    elseif locationName == "bunker" then
        return {
            [1] = workspace:WaitForChild("Zones"):WaitForChild("4"):WaitForChild("Interactables"):WaitForChild("Teleports"):WaitForChild("Locations"):WaitForChild("NuclearBunker")
        }
    elseif locationName == "dino" then
        return {
            [1] = workspace:WaitForChild("Zones"):WaitForChild("5"):WaitForChild("Interactables"):WaitForChild("Teleports"):WaitForChild("Locations"):WaitForChild("DinoWorld")
        }
    elseif locationName == "void" then
        return {
            [1] = workspace:WaitForChild("Zones"):WaitForChild("6"):WaitForChild("Interactables"):WaitForChild("Teleports"):WaitForChild("Locations"):WaitForChild("VoidWorld")
        }
    elseif locationName == "center" then
        return {
            [1] = workspace:WaitForChild("Zones"):WaitForChild("7"):WaitForChild("Interactables"):WaitForChild("Teleports"):WaitForChild("Locations"):WaitForChild("SpaceCenter")
        }
    elseif locationName == "roman" then
        return {
            [1] = workspace:WaitForChild("Zones"):WaitForChild("8"):WaitForChild("Interactables"):WaitForChild("Teleports"):WaitForChild("Locations"):WaitForChild("RomanEmpire")
        }
    elseif locationName == "magma" then
        return {
            [1] = workspace:WaitForChild("Zones"):WaitForChild("8"):WaitForChild("Interactables"):WaitForChild("Teleports"):WaitForChild("Locations"):WaitForChild("Magma World")
        }
    else
        return nil -- Handle unknown location names
    end
end

-- Function to handle button clicks
local function onButtonClick(locationName)
    local locationTable = getLocationTable(locationName)
    if locationTable then
        -- Use the locationTable as needed
        game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("ZoneService"):WaitForChild("RE"):WaitForChild("teleport"):FireServer(unpack(locationTable))
        print("Teleporting to:", locationName)
    else
        print("Unknown location:", locationName)
    end
end

local function createButtons()
    local locations = {"school", "garden", "space", "beach", "bunker", "dino", "void", "center", "roman", "magma"}
    local buttonHeight = 20
    local buttonWidth = 390 / #locations  -- Adjusted width to fit within the menuFrame
    local buttonSpacing = 10

    local maxButtonsPerRow = math.floor(menuFrame.Size.X.Offset / (buttonWidth + buttonSpacing))
    local numRows = math.ceil(#locations / maxButtonsPerRow)

    -- Calculate the yOffset based on the combined height of existing buttons
    local yOffset = 1000  -- Adjust as per the actual button heights and spacing

    for i, locationName in ipairs(locations) do
        local row = math.ceil(i / maxButtonsPerRow)
        local col = i % maxButtonsPerRow
        if col == 0 then
            col = maxButtonsPerRow
        end

        local button = Instance.new("TextButton")
        button.Name = locationName .. "Button"
        button.Text = locationName
        button.Size = UDim2.new(0, buttonWidth, 0, buttonHeight)
        button.Position = UDim2.new(0, 10 + (col - 1) * (buttonWidth + buttonSpacing), 0, yOffset + (row - 1) * (buttonHeight + buttonSpacing))
        button.Parent = menuFrame  -- Parent to menuFrame instead of screenGui

        button.MouseButton1Click:Connect(function()
            onButtonClick(locationName)
        end)
    end
end

-- Call the function to create buttons
createButtons()


-- Function to toggle the farming script and update the button text
local isFarmingToggled = false
local function ToggleAutoFarming()
    local isPlanting = true
    isFarmingToggled = not isFarmingToggled
    
    if isFarmingToggled then
        print("Auto Farm: On")
        autoFarmingButton.Text = "Auto Farm: On"
        -- Add your code to start the farming script
        coroutine.wrap(function()
            while isFarmingToggled do
                for i = 1, 6 do
                    local args
                    if isPlanting then
                        args = {
                            [1] = "Apple Seeds",
                            [2] = "1",
                            [3] = tostring(i)
                        }
                        wait(0.5)
                        game:GetService("ReplicatedStorage").Packages.Knit.Services.ItemPlantingService.RF.Plant:InvokeServer(unpack(args))
                    else
                        args = {
                            [1] = tostring(i)
                        }
                        wait(0.1)
                        game:GetService("ReplicatedStorage").Packages.Knit.Services.ItemPlantingService.RF.Harvest:InvokeServer(unpack(args))
                    end
                end
                isPlanting = not isPlanting
            end
        end)()
    else
        print("Auto Farm: Off")
        autoFarmingButton.Text = "Auto Farm: Off"
        -- Add your code to stop the farming script
    end
end

-- Function to toggle auto snack crafting and update the button text
local isAutoSnackToggled = false
local function ToggleAutoSnackCrafting()
    isAutoSnackToggled = not isAutoSnackToggled
    
    if isAutoSnackToggled then
        print("Auto Snack Crafting: On")
autoSnackButton.Text = "Auto Snack Crafting: On"
        coroutine.wrap(function()
            while isAutoSnackToggled do
                for i = 1, 3 do
                    local args = {
                        [1] = {
                            ["Item"] = "Apple",
                            ["Tier"] = 1
                        }
                    }
                    
                    game:GetService("ReplicatedStorage").Packages.Knit.Services.ItemCraftingService.RF.UpgradeSnack:InvokeServer(unpack(args))
                    
                    local args = {
                        [1] = {
                            ["Item"] = "Apple",
                            ["Tier"] = 2
                        }
                    }
                    game:GetService("ReplicatedStorage").Packages.Knit.Services.ItemCraftingService.RF.UpgradeSnack:InvokeServer(unpack(args))
                    
                end
            end
        end)()
    else
        print("Auto Snack Crafting: Off")
        autoSnackButton.Text = "Auto Snack Crafting: Off"
        -- Add your code to stop auto snack crafting here
    end
end

-- Function to toggle auto merchant and update the button text
    local isAutoMerchantToggled = false
    local function ToggleAutoMerchant()
        isAutoMerchantToggled = not isAutoMerchantToggled
        
        if isAutoMerchantToggled then
            print("Auto Merchant: On")
            autoMerchantButton.Text = "Auto Merchant: On"
            coroutine.wrap(function()
                while isAutoMerchantToggled do
                    for i = 1, 1 do
                        local args = {
                            [1] = "Farmer",
                            [2] = 2
                        }
                        wait(1)
                        game:GetService("ReplicatedStorage").Packages.Knit.Services.MerchantService.RF.BuyItem:InvokeServer(unpack(args))
                    end

                    wait(1)

                    -- for i = 1, 1 do
                    --     local args = {
                    --         [1] = "Farmer",
                    --         [2] = 3
                    --     }
                    --     wait(1)
                    --     game:GetService("ReplicatedStorage").Packages.Knit.Services.MerchantService.RF.BuyItem:InvokeServer(unpack(args))
                    -- end
                end
            end)()
        else
            print("Auto Merchant: Off")
            autoMerchantButton.Text = "Auto Merchant: Off"
            -- Add your code to stop auto merchant here
        end
    end

-- Function to toggle auto fight and update the button text
    local isAutoFightToggled = false
local function ToggleAutoFight()
    isAutoFightToggled = not isAutoFightToggled

    if isAutoFightToggled then
        print("Auto Fight: On")
        autoFightButton.Text = "Auto Fight: On"
        -- Add your code to start the auto fight script
        coroutine.wrap(function()
            while isAutoFightToggled do
                    local args1 = {
                        [1] = {
                        ["Value"] = "Rogue",
                        ["AutoType"] = "AutoFight",
                        ["Value2"] = "8"
                   }
                  }
                game:GetService("ReplicatedStorage").Packages.Knit.Services.IdleTeleportService.RF.SetLatestTeleportData:InvokeServer(unpack(args1))

                local args2 = {
                    [1] = "Rogue",
                    [2] = workspace.GameObjects.ArmWrestling:FindFirstChild("8").NPC.Rogue.Table,
                    [3] = "8"
                }
                game:GetService("ReplicatedStorage").Packages.Knit.Services.ArmWrestleService.RE.onEnterNPCTable:FireServer(unpack(args2))
                
                wait(3)

                for i = 1, 25 do
                    game:GetService("ReplicatedStorage").Packages.Knit.Services.ArmWrestleService.RE.onClickRequest:FireServer()
                    wait(.1)
                end
            end
        end)()
    else
        print("Auto Fight: Off")
        autoFightButton.Text = "Auto Fight: Off"
        -- Add your code to stop the auto fight script
    end
end


-- Function to toggle auto hatch and update the button text
local isAutoMythLegendHatchToggled = false
local function ToggleHatch()
    isAutoMythLegendHatchToggled = not isAutoMythLegendHatchToggled

    if isAutoMythLegendHatchToggled then
        print("Auto Fight: On")
        AutoMythLegendHatchButton.Text = "Auto Hatch: On"
        -- Add your code to start the auto fight script
        coroutine.wrap(function()
            while isAutoMythLegendHatchToggled do
                local args = {
                    [1] = "Blackhole",
                    [2] = {
                        ["GrassMage"] = true,
                        ["MagicMage"] = true,
                        ["Spooky"] = true,
                        ["WaterMage"] = true
                    },
                    [4] = false,
                    [5] = true
                }
            
                game:GetService("ReplicatedStorage").Packages.Knit.Services.EggService.RF.purchaseEgg:InvokeServer(unpack(args))

                -- local args = {
                --     [1] = "Icy",
                --     [2] = {
                --         ["Fox"] = true,
                --         ["Bear"] = true,
                --         ["Slime"] = true,
                --         ["Deer"] = true,
                --         ["Squirrel"] = true
                --     },
                --     [4] = false,
                --     [5] = true
                -- }

                -- game:GetService("ReplicatedStorage").Packages.Knit.Services.EggService.RF.purchaseEgg:InvokeServer(unpack(args))
                -- game:GetService("ReplicatedStorage").Packages.Knit.Services.EggService.RF.purchaseEgg:InvokeServer(unpack(args))
                -- game:GetService("ReplicatedStorage").Packages.Knit.Services.EggService.RF.purchaseEgg:InvokeServer(unpack(args))
                -- game:GetService("ReplicatedStorage").Packages.Knit.Services.EggService.RF.purchaseEgg:InvokeServer(unpack(args))
                -- game:GetService("ReplicatedStorage").Packages.Knit.Services.EggService.RF.purchaseEgg:InvokeServer(unpack(args))
            end
        end)()
    else
        print("Auto Hatch: Off")
        AutoMythLegendHatchButton.Text = "Auto Hatch: Off"
        -- Add your code to stop the auto fight script
    end
end

local isPremiumHatchEggToggled = false
local function ToggleHatchPremium()
    isPremiumHatchEggToggled = not isPremiumHatchEggToggled

    if isPremiumHatchEggToggled then
        print("Auto HatchPrem: On")
        autoHatchPremiumButton.Text = "Auto HatchPrem: On"
        -- Add your code to start the auto fight script
        coroutine.wrap(function()
            while isPremiumHatchEggToggled do
                local args = {
                    [1] = "Praetorian",
                    [2] = {
                        ["VigilantCenturion"] = true,
                        ["FuryGuardian"] = true,
                        ["ProwlingGuard"] = true
                    },
                    [4] = false,
                    [5] = true
                }
                
                game:GetService("ReplicatedStorage").Packages.Knit.Services.EggService.RF.purchaseEgg:InvokeServer(unpack(args))
            end
        end)()
    else
        print("Auto HatchPrem: Off")
        autoHatchPremiumButton.Text = "Auto HatchPrem: Off"
        -- Add your code to stop the auto fight script
    end
end


local isAutoSlimeToggled = false

local function ToggleAutoSlime(pettoslime)
    isAutoSlimeToggled = not isAutoSlimeToggled

    if isAutoSlimeToggled then
        print("Auto Slime: On")
        autoSlimeButton.Text = "Auto Slime: On"
        
        -- Add your code to start the auto slime script
        coroutine.wrap(function()
            while isAutoSlimeToggled do
                -- Declare a persistent variable to store the index for resliming
                local persistentIndex = nil

                -- Function to reset the persistent index
                local function resetPersistentIndex()
                    persistentIndex = nil
                end

                -- Function to check if the current pet index matches the persistent index
                local function shouldReslime(currentIndex)
                    return persistentIndex and currentIndex == persistentIndex
                end

                local Playerz = game:GetService("Players")

                -- Get the LocalPlayer
                local localPlayerz = Playerz.LocalPlayer

                -- Run the script until the slime becomes "Red"
                repeat
                    -- Prepare arguments for the server invocation
                    local args = {
                        [1] = localPlayerz
                    }

                    -- Invoke the server function to get owned pets
                    local OwnedPets = game:GetService("ReplicatedStorage").Packages.Knit.Services.PetService.RF.getOwned:InvokeServer(unpack(args))

                    if OwnedPets then
                        for idx, pet in pairs(OwnedPets) do
                            local displayName = pet.DisplayName
                            local locked = pet.Locked
                            local slime = pet.Slime
                            local key = pet.Key
                            local size = pet.CraftType

                            if key == pettoslime and size == "Goliath" and slime ~= "Red" then
                                print("displayName:", pettoslime, "| Slime:", slime)

                                if slime == nil then 
                                    args = {
                                        [1] = idx
                                    }
                                    game:GetService("ReplicatedStorage").Packages.Knit.Services.PetDeslimeService.RE.onPurchase:FireServer(unpack(args))
                                    wait(.1)
                                    game:GetService("ReplicatedStorage").Packages.Knit.Services.PetService.RF.slimify:InvokeServer(unpack(args))
                                    print("Sliming...")
                                    wait(1)

                                    -- Save the index to persistent variable for resliming
                                    persistentIndex = idx
                                elseif slime ~= "Red" then
                                    args = {
                                        [1] = idx
                                    }

                                    game:GetService("ReplicatedStorage").Packages.Knit.Services.PetDeslimeService.RE.onPurchase:FireServer(unpack(args))
                                    print("Desliming...")

                                    -- Wait for 3 minutes
                                    local countdown = 180 -- 3 minutes in seconds
                                    while countdown > 0 do
                                        print("Remaining time:", countdown, "seconds")
                                        wait(10)
                                        countdown = countdown - 10
                                    end
                                    game:GetService("ReplicatedStorage").Packages.Knit.Services.PetDeslimeService.RE.onClaim:FireServer()
                                end
                            elseif shouldReslime(idx) then
                                -- Check if the current pet index matches the persistent index for resliming
                                args = {
                                    [1] = idx
                                }

                                game:GetService("ReplicatedStorage").Packages.Knit.Services.PetService.RF.slimify:InvokeServer(unpack(args))
                                print("Resliming...")
                                wait(1)

                                -- Reset the persistent index after resliming
                                resetPersistentIndex()
                            else
                                -- Handle other cases or leave it empty if no specific action is needed.
                            end
                        end
                    else
                        print("OwnedPets is nil.")
                    end
                until persistentIndex == nil -- Continue the loop until the slime becomes "Red"
                wait(1) -- Add a wait after the loop
            end
        end)()
    else
        print("Auto Slime: Off")
        autoSlimeButton.Text = "Auto Slime: Off"
    end
end

local StarterGui = game:GetService("StarterGui")

local function ToggleConsole()
        coroutine.wrap(function()
            local currentVisibility = StarterGui:GetCore("DevConsoleVisible")
            StarterGui:SetCore("DevConsoleVisible", not currentVisibility)
        end)()
end

    
-- Function to remove the menu
local function RemoveMenu()
    screenGui:Destroy()
end

-- Connect the functions to the buttons' Click events
toggleButton.MouseButton1Click:Connect(ToggleMenuVisibility)
autoFarmingButton.MouseButton1Click:Connect(ToggleAutoFarming)
autoSnackButton.MouseButton1Click:Connect(ToggleAutoSnackCrafting)
autoMerchantButton.MouseButton1Click:Connect(ToggleAutoMerchant)
autoFightButton.MouseButton1Click:Connect(ToggleAutoFight)
-- Connect the functions to the buttons' Click events
autoSlimeButton.MouseButton1Click:Connect(function()
    ToggleAutoSlime(pettoslime)  -- Replace "YourPetToSlime" with the actual pet to slime
end)
consoleButton.MouseButton1Click:Connect(ToggleConsole)
AutoMythLegendHatchButton.MouseButton1Click:Connect(ToggleHatch)
autoHatchPremiumButton.MouseButton1Click:Connect(ToggleHatchPremium)
removeButton.MouseButton1Click:Connect(RemoveMenu)



